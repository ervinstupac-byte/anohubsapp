/**
 * MarketBridge.ts
 * 
 * Energy Market Integration
 * Connects to electricity spot markets for real-time pricing
 * and calculates market value generated by the fleet
 */

export interface MarketPrice {
    timestamp: number;
    price: number; // EUR/MWh
    zone: string; // e.g., "HR-1" for Croatia
}

export interface ProductionValue {
    timestamp: number;
    production: number; // MW
    price: number; // EUR/MWh
    value: number; // EUR (production * price)
}

export class MarketBridge {
    private static priceHistory: MarketPrice[] = [];
    private static currentPrice: number = 85.50; // EUR/MWh

    /**
     * Fetch current market price (would connect to real API)
     */
    public static async getCurrentPrice(): Promise<MarketPrice> {
        // In production: Fetch from HUPX (Hungarian Power Exchange) or similar
        // const response = await fetch('https://api.hupx.hu/spot/price');

        // Simulated price with realistic variation
        const variation = (Math.random() - 0.5) * 10;
        this.currentPrice = Math.max(20, Math.min(150, this.currentPrice + variation));

        const price: MarketPrice = {
            timestamp: Date.now(),
            price: this.currentPrice,
            zone: 'HR-1'
        };

        this.priceHistory.push(price);

        // Keep last 24 hours
        const dayAgo = Date.now() - 24 * 60 * 60 * 1000;
        this.priceHistory = this.priceHistory.filter(p => p.timestamp >= dayAgo);

        return price;
    }

    /**
     * Calculate market value for production
     */
    public static calculateProductionValue(
        production: number, // MW
        price?: number // EUR/MWh (optional, uses current if not provided)
    ): number {
        const effectivePrice = price || this.currentPrice;
        return production * effectivePrice; // EUR/hour
    }

    /**
     * Get price forecast (simplified - would use ML model in production)
     */
    public static getPriceForecast(hours: number = 24): MarketPrice[] {
        const forecast: MarketPrice[] = [];
        let basePrice = this.currentPrice;

        for (let i = 0; i < hours; i++) {
            const hour = new Date(Date.now() + i * 60 * 60 * 1000).getHours();

            // Realistic price pattern: higher during peak hours (7-22)
            let multiplier = 1.0;
            if (hour >= 7 && hour <= 10) multiplier = 1.3; // Morning peak
            else if (hour >= 18 && hour <= 21) multiplier = 1.5; // Evening peak
            else if (hour >= 0 && hour <= 5) multiplier = 0.7; // Night valley

            const price = basePrice * multiplier + (Math.random() - 0.5) * 5;

            forecast.push({
                timestamp: Date.now() + i * 60 * 60 * 1000,
                price: Math.max(20, Math.min(150, price)),
                zone: 'HR-1'
            });
        }

        return forecast;
    }

    /**
     * Calculate optimal dispatch strategy
     * Given price forecast and generation constraints
     */
    public static calculateOptimalDispatch(
        priceForecast: MarketPrice[],
        maxCapacity: number, // MW
        minCapacity: number // MW
    ): {
        hour: number;
        recommendedLoad: number; // MW
        expectedRevenue: number; // EUR/h
    }[] {
        return priceForecast.map(forecast => {
            const hour = new Date(forecast.timestamp).getHours();

            // Simple strategy: maximize during high prices
            let recommendedLoad: number;
            if (forecast.price > 100) {
                recommendedLoad = maxCapacity; // Full load
            } else if (forecast.price > 70) {
                recommendedLoad = maxCapacity * 0.8; // 80% load
            } else if (forecast.price > 50) {
                recommendedLoad = maxCapacity * 0.6; // 60% load
            } else {
                recommendedLoad = minCapacity; // Minimum load
            }

            const expectedRevenue = recommendedLoad * forecast.price;

            return {
                hour,
                recommendedLoad,
                expectedRevenue
            };
        });
    }

    /**
     * Get historical price statistics
     */
    public static getPriceStatistics(): {
        current: number;
        avg24h: number;
        min24h: number;
        max24h: number;
        trend: 'RISING' | 'STABLE' | 'FALLING';
    } {
        if (this.priceHistory.length === 0) {
            return {
                current: this.currentPrice,
                avg24h: this.currentPrice,
                min24h: this.currentPrice,
                max24h: this.currentPrice,
                trend: 'STABLE'
            };
        }

        const prices = this.priceHistory.map(p => p.price);
        const avg24h = prices.reduce((a, b) => a + b, 0) / prices.length;
        const min24h = Math.min(...prices);
        const max24h = Math.max(...prices);

        // Determine trend
        const recent = prices.slice(-6); // Last 6 data points
        const older = prices.slice(-12, -6);
        const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
        const olderAvg = older.length > 0 ? older.reduce((a, b) => a + b, 0) / older.length : recentAvg;

        let trend: 'RISING' | 'STABLE' | 'FALLING';
        if (recentAvg > olderAvg * 1.05) trend = 'RISING';
        else if (recentAvg < olderAvg * 0.95) trend = 'FALLING';
        else trend = 'STABLE';

        return {
            current: this.currentPrice,
            avg24h,
            min24h,
            max24h,
            trend
        };
    }
}
